<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Document</title>
</head>
<body>
    <div id="top" class="header">
        <h1>Portfolio Boi</h1>
    </div>
    <div class="navigation">
        <a href="index_nl.html">Projecten</a>
        <a href="aboutme_nl.html">About Me & Contact</a>
    </div>
    <div class="projectpage">
        <h2 id="fishtanksandbox">Fish Tank Sandbox</h2>
        <div class="projectview">
            <video loop autoplay controls src="projects/FishTankSandbox/fishtanksandboxgameplay1.webm"></video>
            <img src="projects/FishTankSandbox/fishgameplay.png" alt="">
        </div>
        <a href="https://github.com/Boil-1/FishTankSandBox" target="_blank">Repository</a>
        <div class="projecttext">
            <h2>Introduction</h2>
            <p>
                Ik begon dit project in de zomer van het eerste jaar omdat ik wilde blijven programmeren terwijl ik niet op school was,
                het project is vaak gepauzeerd meestal vanwege school, andere projecten of ik verloor interese. Er zijn verschillende delen meerdere keren herschreven, 
                het was het eerste project wat ik maakte groot en deels zonder hulp van internet of andere mensen.
            </p>
            <br>
            <h2>Functional</h2>
            <h3>The Tank</h3>
            <p>
                Wanneer het spel start begin je met 1 vis die rond zwemt in het aquarium. Dit is altijd een rode vis.
                Links boven in is een knop genaamd "spawn food" als het eten word gespawned
                zwemt de vis er naartoe en eet hij het op. Elke keer nadat de vis 5 stukken eten heeft gegeten groeit hij.
                Wanneer 2 vissen langs elkaar zwemmen is het mogelijk dat 1 van hun een ei legt.
                Als je de vis geen eten geeft gaat hij DOOD. De andere knop links boven in is de "go to pond" knop. Wanneer deze is ingedrukt
                ga je naar een ander scherm met een vis hengel waar je andere vissen kan vissen.
            </p>
            <br>
            <h3>The Pond</h3>
            <p>
                De twee knoppen links boven in zijn "open bail" en "hook view".
                Wanneer open bail word ingedrukt zal de haak snel naar beneden gaan. Met deze knop kan je snel bij de bodem komen.
                Met de andere knop kan je zien waar de haak is. Als dit niet is ingeschakeld kan je de hengel verslepen met je muis.
                Als de haak te snel langs de vissen gaat schrikken de vissen in de vijver en zwemmen ze weg.
                Je kan een vis vangen door de haak stil te hangen tot dat een vis de haak bijt. Als de vis aan je haak zit
                moet je de haak héél langzaam naar boven bewegen anders ontsnapt de vis. Wanneer je de top bereikt
                is de vis gevangen en een scherm met de statestieken van de vis komt te voorschijn. In dit scherm kan je de vis een naam geven
                Je hebt ook de keuzen om de vis te verkopen of om hem in je aquarium te stoppen. Verzamel alle soorten vissen om het spel uit te spelen. 
            </p>
            <br>
            <h2 id="Technicalfish">Technical</h2>
            <h3>The Tank</h3>
            <p>
                Wanneer het spel start een vis game object word <a href="#instantiatefish">geinstantieerd op een willekeurige positie.</a> Daarna word hij toegevoegd aan een instantie van de <a href="#fishclass">fish class</a> <br>
                Als de spawn food knop is ingedrukt een bool word aangezet en wanneer de linker muis knop word ingedrukt <br>
                het food game object <a href="#instantiatefood">word geinstantieerd</a> op de positie van de muis  en word toegevoegd aan de food list. <br>
                Al het gedrag van de vis draait in een functie genaamd <a href="#fishbehaviour">FishBehaviour()</a> behalve het gedeelte waarmee de eieren gelegd worden. <br>
                Dit gedeelte draait in de <a href="#egging">Egging()</a> functie. In de FishBehaviour functie worden de lucht bubbels geinstantieerd, de statestieken worden bij gehouden, <br>
                de sprite word <a href="#flipped">geflipt</a> afhankelijk als de pos.x groter is dan zijn eigen x positie. Elke keer als de vis bij het punt aankomt waar hij heen zwemt <br>
                word 1 afgetrokken van de hunger waarde. Deze functie zorgt er ook voor dat de vissen <a href="#movetofood">naar het eten toe zwemmen</a> als ze dichtbij genoeg zijn. <br>
                Wanneer de vis dichtbij genoeg is bij het food game object word het vernietigt en uit de food list gehaald. De grow waarde neemt toe met 1. <br>
                Afhankelijk van de hunger waarde de beweeg snelheid word veranderd, dit word gedaan in een <a href="#switchstatement">switch statement.</a> 
            </p>
            <br>
            <h3>The Pond</h3>
            <p>
                Wanneer je deze scene opent zijn er 2 knoppen links boven in; open bail en hook view. Als de open bail knop is ingedrukt <br>
            gaat in de Scrolling() functie de haak zijn transform <a href="#goingdown">snel naar beneden.</a> De haak stopt met zakken wanneer hij aankomt bij y -80. <br>
            Als de hook view knop is ingedrukt gaat de word de positie van de camera naar de <a href="#hookview">y positie van de haak gezet</a> en daarna geparent. Het is ook mogelijk <br>
            om de haak handmatig te bewegen met behulp van <a href="#movehookupdown">het scrollwiel.</a> Wanneer de haak dichtbij een vis is en de afstand tussen de oude en huidige positie is<br>
            <a href="#scaredfish">> 1.33f</a> zal de vis ontsnappen en verliest hij 1 interest. Maar als je de haak stil kan houden kunnen vissen <a href="">geintereseerd worden</a> in de haak <br>
            De interest waarde word bij gehouden in een int. Door Random.Range() te gebruiken zal de vis of direct de haak bijten of door zwemmen maar terug komen. Wanneer de vis is geintereseerd <br>
            kijkt hij richting de haak en als de interest waarde 3 of groter is zal er een bool genaamd isInterested naar true worden gezet en <br>
            de vis zal naar de haak bewegen en hij word <a href="#hooked">geparent aan de hook.</a> Nadat de vis geparent is aan de haak zal de FishEscape() functie <br>
            starten, die checkt of de afstand van de haak tussen de oude en huidige positie > 1.33f. Als dat zo is raakt de vis los <br>
            dit word gedaan op de zelfde manier als hoe de vis weg zwemt als de haak te snel langs komt. Als de fish transform boven y -1 komt word de catched <br>
            bool op true gezet. Nu deze bool true is <a href="UIappears">verschijnt er een UI element</a> waarin je de statestieken van de vis kan zien, zijn naam kan veranderen en <br>
            hem kan verkopen of houden. De rest in nog in ontwikkeling.    
            </p>
        </div>
        <br>
        <br>
        <br>
        <br>
        <div class="snippet">
            <h2>snippets</h2>
            <pre>
<code>
    <span class="annotation">//code from the fish tank scene</span>
    <span id="instantiatefish" class="annotation">//instantiates the fish and adds him to the list:</span>
    <a href="#Technicalfish">to top</a>

    int numbermf = UnityEngine.Random.class="method">RandomRange(class="value">0,class="value">2);
    GameObject spawnedfish = class="method">Instantiate(fish);
    Fish fc = new Fish(new Vector3(UnityEngine.Random.Range-8, 8), UnityEngine.Random.Range(-4, 5), 0), spawnedfish, 
        randomname[UnityEngine.Random.Range(0, 5)], type.red, 1f, 4f, 20, 2f, airbubble;
    fishes.Add(fc);
    if (numbermf == 0)
    {                                                           
        fc.malefemale = mf.male;
        malefish.Add(fc);
    }
    else
    {
        fc.malefemale = mf.female;
        fishes.Add(fc);
    }

    <span id="fishclass" class="annotation">//fish class (this is already changed because this looks REALY bad)</span>
    <a href="#Technicalfish">to top</a>

    public class Fish
    {
        public Vector3 pos;
        public Vector3 previouspos;
        public GameObject gameobject;
        public bool passed = false;
        public string name;
        public int id;
        public type type;
        public mf malefemale;
        public float speed;
        public float originalspeed;
        public float range;
        public int hunger;
        public bool alive = true;
        public bool changespeed = true;
        public int growstate = 0;
        public string growstring;
        public bool foodisntalive = true;
        public GameObject airbubble;
        public float breathe = 0.0f;
        public float rate;
        public List&ltFish> fishmemory = new List&ltFish>();
        public List&ltint> amountfishpassed = new List&ltint>();
        public bool cameviaegg;
        public Fish(Vector3 _pos, GameObject _gameobject, string _name, type _type, float _speed, float _range, int _hunger, float _originalspeed, GameObject _airbubble)
        {
            pos = _pos;
            gameobject = _gameobject;
            name = _name;
            type = _type;
            speed = _speed;
            originalspeed = _originalspeed;
            range = _range;
            hunger = _hunger;
            airbubble = _airbubble;
        }
    }

    <span id="instantiatefood" class="annotation">//food gets instantiated</span>
    <a href="#Technicalfish">to top</a>

    if (Input.GetMouseButtonDown(0) && canvas.GetComponentInChildren&ltbuttons>().click && !EventSystem.current.IsPointerOverGameObject())
    {
        spawnedfood = Instantiate(fishfood);
        foodlist.Add(spawnedfood);
        spawnedfood.transform.position = mouse.transform.position;
    }

    <span id="fishbehaviour" class="annotation">//the FishBehaviour() function</span>
    <a href="#Technicalfish">to top</a>

    public void FishBehaviour(List&Fish> fishlist)
    {
        foreach (Fish fish in fishlist.ToList())
        {
            if (fish.alive)
            {
                fish.rate = UnityEngine.Random.Range(1, 10);
                if (Time.time > fish.breathe)
                {
                    fish.breathe = Time.time + fish.rate;
                    GameObject Iairbubble = Instantiate(airbubble);
                    if (fish.pos.x > fish.gameobject.transform.position.x)
                        Iairbubble.transform.position = new Vector3(fish.gameobject.transform.position.x+fish.gameobject.transform.localScale.x*0.8f, fish.gameobject.transform.position.y);
                    else
                        Iairbubble.transform.position = new Vector3(fish.gameobject.transform.position.x-fish.gameobject.transform.localScale.x * 0.8f, fish.gameobject.transform.position.y);
                    allairbubbles.Add(Iairbubble);
                }
            }
            if (fish.alive)
            {
                fish.gameobject.transform.position += (fish.pos - fish.gameobject.transform.position).normalized * Time.deltaTime * fish.speed;
                if(fish.pos == fish.previouspos)
                    fish.pos = new Vector3(UnityEngine.Random.Range(-8, 8), UnityEngine.Random.Range(-4, 5), 0);
                if (Vector3.Distance(fish.gameobject.transform.position, fish.pos) &lt 1f && fish.foodisntalive)
                {
                    fish.pos = new Vector3(UnityEngine.Random.Range(-9, 9), UnityEngine.Random.Range(-4, 5), 0);        
                    fish.hunger--;
                    fish.changespeed = true;
                }
            }
            //more code
        }
    }

    <span id="egging" class="annotation">//how fish lay eggs</span>
    <a href="#Technicalfish">to top</a>

    public void Egging()
    {
        foreach (Fish m in malefish)
        {
            foreach (Fish f in femalefish)
            {
                float fishDistance = 999;
                Fish closestFish = null;
                if((f.gameobject.transform.position - m.gameobject.transform.position).magnitude &lt fishDistance)
                {
                    fishDistance = (f.gameobject.transform.position - m.gameobject.transform.position).magnitude;
                    closestFish = f;
                }
                if (fishDistance &lt 0.6f && !m.passed)
                {
                    if (!m.fishmemory.Contains(closestFish))
                    {
                        m.fishmemory.Add(closestFish);
                        m.amountfishpassed.Add(1);
                        m.passed = true;
                    }
                    else
                    {
                        for (int i = 0; i &lt m.fishmemory.Count; i++)
                        {
                            if (m.amountfishpassed[i] == 8)
                            {
                                GameObject Iegg = Instantiate(FishEgg);
                                Iegg.transform.position = m.fishmemory[i].gameobject.transform.position;
                                m.amountfishpassed[i] = 0;
                            }
                            else
                            {
                                m.amountfishpassed[i]++;
                                m.passed = true;
                            }
                        }
                    }
                }
                if (fishDistance > 2)
                    m.passed = false;
            }
        }
    }

    <span id="flipped" class="annotation">flips the sprite</span>
    <a href="#Technicalfish">to top</a>

    if (fish.pos.x &lt fish.gameobject.transform.position.x)
        fish.gameobject.GetComponent&ltSpriteRenderer>().flipX = true;
    if (fish.pos.x > fish.gameobject.transform.position.x)
        fish.gameobject.GetComponent&ltSpriteRenderer>().flipX = false;

    <span id="movetofood" class="annotation">move to the closest food</span>
    <a href="#Technicalfish">to top</a>

    float closestFoodDistance = 999;
    GameObject closestFood = null;
    foreach (GameObject fo in GetComponent&ltfood>().foodlist)
    {
        if ((fo.transform.position - fish.gameobject.transform.position).magnitude &lt closestFoodDistance && fish.hunger &lt 19)
        {
            closestFoodDistance = (fo.transform.position - fish.gameobject.transform.position).magnitude;
            closestFood = fo;
        }
        if (closestFoodDistance &lt fish.range)
            fish.pos = fo.transform.position;
        if (closestFoodDistance &lt 1f && fish.alive && fish.hunger &lt 19)
        {
            fish.hunger += 3;
            if (fish.gameobject.transform.localScale.y &lt 0.22f)
            {
                fish.growstate++;
                if (fish.growstate == 5)
                {
                    fish.gameobject.transform.localScale *= 1.1f;
                    fish.range += 0.1f;
                    fish.growstate = 0;
                }
            }
            GameObject todelete = fo;
            Destroy(todelete);
        }
    }

    <span id="switchstatement" class="annotation">change movement speeds</span>
    <a href="#Technicalfish">to top</a>
    
    switch (fish.hunger)
    {
        case 20:
            fish.speed = fish.originalspeed;
            break;
        case 15:
            if (fish.changespeed)
                fish.speed = fish.originalspeed * 0.8f;
            fish.changespeed = false;
            break;
        case 10:
            if (fish.changespeed)
                fish.speed = fish.originalspeed * 0.6f;
            fish.changespeed = false;
            break;
        case 5:
            if (fish.changespeed)
                fish.speed = fish.originalspeed * 0.4f;
            fish.changespeed = false;
            break;
        case 2:
            if (fish.changespeed)
                fish.speed = fish.originalspeed * 0.2f;
            fish.changespeed = false;
            break;
        case 0:
            if (fish.alive)
            {
                fish.alive = false;
            }
            fish.gameobject.GetComponent&ltSpriteRenderer>().flipY = true;
            if (fish.gameobject.transform.position.y > -4f)
                fish.gameobject.transform.position += (new Vector3(fish.gameobject.transform.position.x, -4) - fish.gameobject.transform.position).normalized * Time.deltaTime * 1.5f;
            break;
    }

    <span class="annotation">//code from the pond scene</span>
    <span id="goingdown" class="annotation">//hook going down</span>
    <a href="#Technicalfish">to top</a>

    if (sinking && Distance &lt 99)
    {
        hook.transform.position += new Vector3(0, -40) * Time.deltaTime;
        Distance = transform.position.y - hook.transform.position.y;
    }

    <span id="hookview" class="annotation">//parent camera to hook</span>
    <a href="#Technicalfish">to top</a>

    public void HookView()
    
    {
        if (!click2)
        {
            Camera.main.transform.position = new Vector3(0, hook.transform.position.y, Camera.main.transform.position.z);
            button2.image.sprite = clickedbutton;
            click2 = true;
            Camera.main.transform.parent = hook.transform;
        }
        else
        {
            Camera.main.transform.position = new Vector3(0, 0, Camera.main.transform.position.z);
            button2.image.sprite = unclickedbutton;
            click2 = false;
            Camera.main.transform.parent = null;
        }
    }

    <span id="movehookupdown" class="annotation">//move the hook up and down using the scrollwheel</span>
    <a href="#Technicalfish">to top</a>

    void Scrolling()
    {
        List&ltWildFish> wfishes = GameObject.Find("thepond").GetComponent&ltWildFishSpawn>().wildfishes;
        if (Input.GetAxis("Mouse ScrollWheel") &lt 0 && Distance &lt 100 && !sinking)
        {
            hook.transform.position += new Vector3(0, -80) * Time.deltaTime;
            Distance = transform.position.y - hook.transform.position.y;
        }
        else if(Input.GetAxis("Mouse ScrollWheel") > 0 && Distance > 4)
        {
            hook.transform.position += new Vector3(0, 80) * Time.deltaTime;
            Distance = transform.position.y - hook.transform.position.y;
        }
        //more code
    }

    <span id="scaredfish" class="annotation">//fish get scared when the hook is moving too fast</span>
    <a href="#Technicalfish">to top</a>

    if ((fish.gameobject.transform.position - hook.transform.position).magnitude &lt 4)
    {
        if ((originalhookpos - hook.transform.position).magnitude > 1.33f && !fish.gone)
        {
            fish.gone = true;
            fish.pos = new Vector3(-fish.pos.x, fish.pos.y);
            fish.speed = fish.originalspeed * 4.5f;
        }
    }

    <span id="interestedinhook" class="annotation">//how fish get interested in the hook</span>
    <a href="#Technicalfish">to top</a>

    if ((closestFish.gameobject.transform.position - hook.transform.position).magnitude &lt 1.5f && !closestFish.gone && !hooked) 
    {
        if (closestFish.isinterested)
        {
            closestFish.interest += Random.Range(1, 4);
            closestFish.isinterested = false;
        }
        Vector2 direction = hook.transform.position - closestFish.gameobject.transform.position;
        if (closestFish.gameobject.transform.position.x > hook.transform.position.x)
        {
            fish.gameobject.transform.right = direction;
            fish.gameobject.GetComponent&ltSpriteRenderer>().flipX = false;
            fish.gameobject.GetComponent&ltSpriteRenderer>().flipY = true;
        }
        else if (closestFish.gameobject.transform.position.x &lt hook.transform.position.x)
        {
            fish.gameobject.transform.right = -direction;
            fish.gameobject.GetComponent&ltSpriteRenderer>().flipX = true;
            fish.gameobject.GetComponent&ltSpriteRenderer>().flipY = false;
        }
    }

    <span id="hooked" class="annotation">how the fish bites the hook</span>
    <a href="#Technicalfish">to top</a>

    if (closestFish.interest > 3 && !hooked)
    {
        closestFish.pos = hook.transform.position;
        if ((closestFish.gameobject.transform.position - closestFish.pos).magnitude &lt 0.5f)
        {
            hf = closestFish;
            hf.bite = true;
            hooked = true;
            hf.gameobject.GetComponent&ltSpriteRenderer>().flipY = false;
            hf.gameobject.GetComponent&ltSpriteRenderer>().flipX = false;
            hook.transform.position = closestFish.gameobject.transform.position;
            hf.gameobject.transform.SetParent(hook.transform, true);             
            hf.gameobject.transform.Rotate(new Vector3(0, 0, 0));
        }
    }

    <span id="UIappears" class="annotation">//UI popup when the fish is catched</span>
    <a href="#Technicalfish">to top</a>

    if (catched)
    {
        fishStat.gameObject.SetActive(true);
        Transform fishname = fishStat.transform.GetChild(1);
        Transform fishtype = fishStat.transform.GetChild(2);
        Transform sex = fishStat.transform.GetChild(3);
        Transform input = fishStat.transform.GetChild(4);
        fishtype.GetComponent&ltText>().text = "Type " + hf.fishtype.ToString();
        sex.GetComponent&ltText>().text = "Sex " + hf.malefemale.ToString();
        if (input.GetComponent&ltText>().text.Length > 0)
            catchedFish.name = input.GetComponent&ltText>().text;
        catchedFish.type = hf.fishtype;
        catchedFish.malefemale = hf.malefemale;
        hf = null;
        catched = false;
    }
</code>
            </pre>
        </div>
        <hr> 
        <!-- ant -->
        <h2 id="antsimulation">Ant Simulation</h2>
        <div class="projectview">
            <video loop autoplay controls src="projects/AntSimulation/Antsimulation-1.webm"></video>
            <img src="projects/AntSimulation/AntGameplay.png" alt="">
        </div>
        <a href="https://github.com/Boil-1/FishTankSandBox" target="_blank">Repository</a>
        <div class="projecttext">
            <h2>Introduction</h2>
            <p>Ik ben begonnen met dit project omdat ik een aantal videos zag van mieren simulaties en ik vond het leuk om te kijken hoe ze rondliepen</p>
            <br>
            <h2>Functional</h2>
            <p>Mieren lopen rond op het schern, wanneer de mier eten heeft  gevonden, loopt hij terug via het zelfde pad hoe hij bij het insect kwam
                Mieren halen eten van insecten die dood op de grond vallen.
                Op het scherm word bij gehouden hoeveel eten er is verzameld en hoeveel mieren er op dit moment rond lopen.
            </p>
            <br>
            <h2 id="technicalant">Technical</h2>
            <p>
                Wanneer het spel start een for loop start die de mieren instantiërt. 
                Het mier game object word toegevoegt aan een instantie van de <a href="#antclass">Ant class</a>.
                Elke mier word toegevoegd aan een lijst genaamd antList. Een <a href="#foreach">foreach loop</a> voert uit in de update functie met een <a href="#switchcase">state machine</a> 
                die de mieren bestuurt. 
                 Er zijn 2 staten; Wandering en Collecting. Als de mier in de wandering staat is kiest hij een wilekeurige positie uit in een radius van 1.5,
                  wanneer de mier in de buurt van zijn positie komt kiest hij een nieuwe wilekeurige positie en zijn huidige positie word <a href="#saveinlist">opgeslagen in een lijst.</a>
                   Dit word herhaald totdat hij dichtbij genoeg is bij een insect.
                   Wanneer de mier in de buurt is van een insect <a href="#collectfood">verzameld hij eten</a> van het insect, dit kan 100 keer gedaan worden voordat het insect word vernietigd.
                    Als de mier eten heeft zijn staat veranderd naar de collecting staat. In deze staat gaat hij terug naar de mierenhoop 
                     <a href="#followpositions">
                    via de posities</a> hij heeft toegevoegd aan de lijst
                    terwijl hij naar het eten opzoek was. Wanneer hij aankomt bij de mierenhoop veranderd zijn staat terug naar wandering.
            </p>
        </div>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <div class="snippet">
            <h2>snippets</h2>
            <pre>
<code>
    <span id="antclass" class="annotation">//ant class</span>
    <a href="#technicalant">to top</a>

    public class Ant
    {
        public List&ltVector3&gt pathToFood = new List&ltVector3&gt();
        public List&ltVector3&gt pathFromHome = new List&ltVector3&gt();
        public GameObject antGameObject;
        public bool getFood;
        public bool hasFood;
        public bool atDestination = true;
        public States state;
        public Vector3 destination = new Vector3(0,0,0);
        public float speed = 0.5f;
        public float radius = 1.5f;
        public int lengt
        public Ant(GameObject _antGameObject)
        {
            antGameObject = _antGameObject;
        }
        public Vector3 position => antGameObject.transform.position;
    }

    <span id="foreach" class="annotation">//ant movement</span>
    <a href="#technicalant">to top</a>

    foreach(Ant ant in antList)
    {
        Vector2 direction = ant.destination - ant.position;
        ant.antGameObject.transform.up = -direction;
        //move
        ant.antGameObject.transform.position += (ant.destination - ant.position).normalized * ant.speed * Time.deltaTime;
        switch (ant.state)
        //rest of the code
    }

    <span id="switchcase" class="annotation">//ant state machine</span>
    <a href="#technicalant">to top</a>

    switch (ant.state)
    {
        case States.Wandering:
        ant.antGameObject.GetComponent&ltSpriteRenderer&gt().sprite = antDefaultSprite;
            //searching for food
            float closestFood = 99;
            Moth closestFoodGameObject = null;
            foreach (Moth moth in mothList)
            {
                if ((moth.position - ant.position).magnitude &lt closestFood && moth.isDead)
                {
                    closestFood = (moth.position - ant.position).magnitude;
                    closestFoodGameObject = moth;
                }
                if (closestFood &lt 0.5f)
                    ant.destination = closestFoodGameObject.position;
                if (closestFood &lt 0.2f)
                {
                    ant.hasFood = true;
                    ant.pathToFood.Add(ant.position);
                    ant.length = ant.pathFromHome.Count;//the path he walked so far
                    if (!ant.getFood)
                    {
                        closestFoodGameObject.health--;
                        ant.getFood = true;
                    }
                    ant.state = States.Collecting;
                }
            }
            break;
        case States.Collecting:
            ant.atDestination = true;
            ant.antGameObject.GetComponent&ltSpriteRenderer&gt().sprite = antCarryFood;
            if ((transform.position - ant.position).magnitude &lt 0.05f)
            {
                ant.getFood = false;
                ant.hasFood = false;
                totalFood++;
                ant.destination = transform.position;
                ant.pathFromHome.Clear();
                ant.state = States.Wandering;
            }
            break;
    }

    <span id="saveinlist" class="annotation">//save position in list</span>
    <a href="#technicalant">to top</a>

    if ((ant.position - ant.destination).magnitude &lt 0.05f && !ant.hasFood)
    {
        ant.destination = new Vector3(Random.Range(ant.position.x - ant.radius, ant.position.x + ant.radius), Random.Range(ant.position.y
         - ant.radius, ant.position.y + ant.radius));
        ant.pathFromHome.Add(ant.position);
    }

    <span id="collectfood" class="annotation">//collect food</span>
    <a href="#technicalant">to top</a>

    if (closestFood &lt 0.2f)
    {
        ant.hasFood = true;
        ant.pathToFood.Add(ant.position);
        ant.length = ant.pathFromHome.Count;//the path he walked so far
        if (!ant.getFood)
        {
            closestFoodGameObject.health--;
            ant.getFood = true;
        }
        ant.state = States.Collecting;
    }

    <span id="followpositions" class="annotation">//follow path</span>
    <a href="#technicalant">to top</a>

    if ((ant.destination - ant.position).magnitude &lt 0.05f && ant.atDestination)
    {                                             
        ant.pathToFood.Add(ant.position);
        if (ant.length > 0)
        {
            ant.length--;
            ant.destination = ant.pathFromHome[ant.length];
        }
        ant.atDestination = false;
    }

</code>
            </pre>
        </div>
        <hr>

        <!--TD-->
        <h2 id="towerdefense">Tower Defense</h2>
        <div class="projectview">
            <video loop autoplay controls src="projects/TowerDefense/Tdgameplay-1.webm"></video>
            <img src="projects/TowerDefense/towerDefenseGameplay.png" alt="">
        </div>
        <a href="https://github.com/Boil-1/FishTankSandBox" target="_blank">Repository</a>
        <div class="projecttext">
            <h2>Introduction</h2>
            <p>Dit is het eerste school project van het tweede jaar op het media college Amsterdam</p>
            <br>
            <h2>Functional</h2>
            <h3>Menu</h3>
            <p>Wanneer het spel start kom je in een menu, je kan het spel starten of het spel afsluiten. Je kan in het menu komen door op escape te drukken.</p>
            <br>
            <h3>Main Game</h3>
            <p>
                Aan de rechter zijde van het scherm is er een menu waar je verschillende torens kan selecteren en upgrades kan kopen voor je karakter. <br>
                De upgrades zijn; een mini map en de mogelijkheid om sneller te rennen. <br>
                Wanneer een toren is geselecteerd kan je met je muis op het scherm bewegen om te zien waar je wel en niet een toren kan plaatsen. <br>
                Als het spel start begint er een timer te lopen, wanneer het 0 is start er een wave. Je kan ook handmatig een wave starten <br>
                door op de start wave knop te drukken in het menu rechts. Wanneer de wave start zal er een groep van 8 vijanden spawnen <br>
                bij het begin van het pad, het begin van het pad is links boven in. Als er torens zijn geplaatst op de map en de wave start beginnen de torens <br> 
                te schieten richting de dichst bijzijnde vijand. 3 verschillende soorten vijanden spawnen willekeurig; <br>
                 de rode vijand is de zwakste hij doet de minste schade en heeft de minste HP, <br>
                de groene vijand doet meer schade en heeft meer HP en de blauwe vijand is de sterkste hij doet de meeste schade en heeft de meeste HP, <br>
                Als de vijanden de basis berijken aan het eind van het pad doen ze schade aan de basis. Wanneer de gezondheid 0 is is het game over <br>
                en een game over scherm verschijnt.
            </p>
            <br>
            <h2>Technical</h2>
            <h3>Menu</h3>
            <p>
                In het menu is er een knop om het spel te starten en om het spel af te sluiten. <br>
                De start knop gaat naar de spel scene en de afsluit knop sluit het spel
            </p>
            <br>
            <h3>Main Game</h3>
            <p>
                Wanneer het spel start een timer zal <a href="#countdown">beginnen met aftellen</a> als het 0 berijkt een <a href="#wave">wave</a> van 8 vijanden start en de vijanden
                worden toegevoegd aan een <a href="#enemylist">lijst.</a> De muis <a href="#check">kijkt</a> of er een toren of pad onder is. Wanneer het spel start een cirkel sprite word 
                <a href="#check">geinstantieerd.</a> Het word <a href="#check">rood</a> als de muis over een pad tegel of een andere toren is. DIt word gedaan door alle torens
                aan een lijst toe te voegen en de afstand berekenen tussen de torens, of als de huidige tegel waar de muis over heen zweeft niet een pad tegel is.
                De sprite word <a href="#check">groen</a> als er niks onder staat.
                Wanneer je klikt wanneer je een toren hebt geselecteerd van het menu <a href="#placetower">een toren game object word geinstantieerd</a>
                en word toegevoegd aan een instantie van de <a href="#towerclass">Tower class.</a>
                wanneer de toren geinstantieerd is word hij toegevoegd aan een lijst.
                Wanneer de vijanden dicht bij de torens komen een kogel word geinstantieerd en <a href="#predictposition">beweegd voor de vijand.</a>
                Als de kogel in de buurt van een vijand komt <a href="#enemydamage">gezondheid word afgetrokken</a> van de vijand. De vijand beweegd naar een lijst van empty game objects als hij
                dichtbij komt het eerste game object in de lijst het game object word <a href="#followpath">verwijderd</a> uit de lijst en de vijand gaat naar de volgende.
                Wanneer de vijand aankomt bij het laatste punt in de lijst doet hij <a href="#damagebase">schade aan de basis</a>, de vijand word vernietigt en gezondheid word afgetrokken van de speler.
            </p>
        </div>
        <br>
        <div class="snippet">
            <h2>Snippets</h2>
            <pre>
<code>
    
    <span id="check" class="annotation">//indicator if tower can be placed</span>
    if (GameObject.Find("Canvas").GetComponent&ltbuttonclicked>().clicktowerselect)
    {
        if (uitowerspawned == null)
            uitowerspawned = Instantiate(uitower);
        if (uitowerspawned != null) 
            uitowerspawned.transform.position = mouse.transform.position;
        if (closestdist &lt 1 || tilemap.GetTile(tilemap.WorldToCell(mouse.transform.position)) == pathtile)  
        {
            uitowerspawned.GetComponent&ltSpriteRenderer>().color = new Color(1, 0, 0, 0.25f);
            canplace = false;
        }
        else
        {

            uitowerspawned.GetComponent&ltSpriteRenderer>().color = new Color(0, 1, 0, 0.25f);
            canplace = true;
        }
    }

    <span id="predictposition" class="annotation">//predict enemy position</span>
    t.bulletdict.Add(ibullet, closestenemy.transform.position
                    + ((GameObject.Find("spawner").GetComponent&ltspawn>().ec.points[0].transform.position
                    - closestenemy.transform.position).normalized * Mathf.Pow(closestedist, 1.25f) / 5f) - t.position);
    //moves it infront of the enemy
    foreach (KeyValuePair&ltGameObject, Vector3> b in t.bulletdict)
    {
        b.Key.transform.position += b.Value * Time.deltaTime * bulletspeed;
    }

    <span id="towerclass" class="annotation">//Tower class</span>
    public class Tower
    {
        public string towername;
        public float bulletspeed;
        public float cooldown;
        public float lastfire = 0f;
        public float damage;
        public float range;
        public int cost;
        public GameObject towerGameObject;
        public Dictionary&ltGameObject, Vector3> bulletdict = new Dictionary&ltGameObject, Vector3>();
        public Vector3 position => towerGameObject.transform.position;
    }

    <span id="countdown" class="annotation">//wave countdown</span>

    if (System.Convert.ToInt32(timertext.text) > 0)
    {
        timertext.text = ((int)(300 - (Time.time - lasttime))).ToString();
        if (System.Convert.ToInt32(timertext.text) == 0 && spawning)
        {
            StartCoroutine(Spawning());
            spawning = false;
            timertext.text = 300.ToString();
        }
        else
        {
            spawning = false;
        }
    }

    <span id="wave" class="annotation">//enemy waves</span>

    public IEnumerator Spawning()
    {
        spawning = false;
        for (int i = 0; i &lt 9; i++)
        {
            //lastspawn = Time.time + cooldown;
            spawnedenemy = Instantiate(basicenemy, transform.position, transform.rotation);
            List&ltEnemy> randomenemy = new List&ltEnemy>() { new Enemy() { enemyGameObject = spawnedenemy, enemyname = "basicenemy", hp = 0.5f, speed = 100f, damage = 1 },
            new Enemy() { enemyGameObject = spawnedenemy, enemyname = "strongerenemy", hp = 1f, speed = 100f, damage = 2 },
            new Enemy() { enemyGameObject = spawnedenemy, enemyname = "strongestenemy", hp = 2f, speed = 100f, damage = 4 } };
            ec = randomenemy[Random.Range(0, 3)];
            enemies.Add(ec);
            for (int ii = 0; ii &lt GameObject.Find("points").transform.childCount; ii++)
                ec.points.Add(GameObject.Find("points").transform.GetChild(ii));
            enemyIndexes.Add(1);
            if (ec.enemyname == "basicenemy")
                ec.enemyGameObject.GetComponent&ltSpriteRenderer>().color = Color.red;
            if (ec.enemyname == "strongerenemy")
                ec.enemyGameObject.GetComponent&ltSpriteRenderer>().color = Color.green;
            if (ec.enemyname == "strongestenemy")
                ec.enemyGameObject.GetComponent&ltSpriteRenderer>().color = Color.blue;
            yield return new WaitForSeconds(0.7f);
        };
    }

    <span id="enemylist" class="annotation">//enemies added to the list</span>

    List&ltEnemy> randomenemy = new List&ltEnemy>() { new Enemy() { enemyGameObject = spawnedenemy, enemyname = "basicenemy", hp = 0.5f, speed = 100f, damage = 1 },
    new Enemy() { enemyGameObject = spawnedenemy, enemyname = "strongerenemy", hp = 1f, speed = 100f, damage = 2 },
    new Enemy() { enemyGameObject = spawnedenemy, enemyname = "strongestenemy", hp = 2f, speed = 100f, damage = 4 } };
    ec = randomenemy[Random.Range(0, 3)];
    enemies.Add(ec);

    <span id="placetower" class="annotation">//place tower</span>
    if (Input.GetMouseButtonDown(0) && uitowerspawned.GetComponent&ltSpriteRenderer>().color != new Color(0, 0, 0, 0f) 
                && tilemap.GetTile(tilemap.WorldToCell(mouse.transform.position)) != pathtile)
    {
        if (GameObject.Find("Canvas").GetComponent&ltbuttonclicked>().click1)
            TowerButton(1);
        if (GameObject.Find("Canvas").GetComponent&ltbuttonclicked>().click2)
            TowerButton(2);
        if (GameObject.Find("Canvas").GetComponent&ltbuttonclicked>().click3)
            TowerButton(3);
        if (GameObject.Find("Canvas").GetComponent&ltbuttonclicked>().click4)
            TowerButton(4);
        if (GameObject.Find("Canvas").GetComponent&ltbuttonclicked>().click5)
            TowerButton(5);
        if (GameObject.Find("Canvas").GetComponent&ltbuttonclicked>().click6)
            TowerButton(6);
        if (GameObject.Find("Canvas").GetComponent&ltbuttonclicked>().click7)
            TowerButton(7);
        if (GameObject.Find("Canvas").GetComponent&ltbuttonclicked>().click8)
            TowerButton(8);
    }

    <span id="enemydamage" class="annotation">//enemy gets damaged</span>

    foreach (KeyValuePair&ltGameObject, Vector3> bt in t.bulletdict)
    {
        foreach (Enemy e in enemies.ToList())
        {
            if ((e.enemyGameObject.transform.position - bt.Key.transform.position).magnitude &lt 1f)
            {
                e.hp -= 0.5f;
                if (e.hp &lt= 0)
                {
                    enemies.Remove(e);
                    Destroy(e.enemyGameObject);
                    GameObject.Find("player").GetComponent&ltplayer>().points += 20;
                }
            }
        }
    }

    <span id="followpath" class="annotation">//enemies follow the path</span>

    if (se.points.Count > 0)
    {
        se.enemyGameObject.transform.position += (se.points[0].transform.position - se.enemyGameObject.transform.position).normalized * Time.deltaTime * 10;    
        if (Vector3.Distance(se.enemyGameObject.transform.position, se.points[0].transform.position) < 0.5f)
            se.points.RemoveAt(0);
    }

    <span id="damagebase" class="annotation">//damage the base</span>

    if (Vector3.Distance(se.enemyGameObject.transform.position, GameObject.Find("player").GetComponent&ltplayer>().thebase.transform.position) < 2)
    {
       deadenemy = se.enemyGameObject;
       if (GameObject.Find("player").GetComponent&ltplayer>().health > 0f)
       {
           GameObject.Find("player").GetComponent&ltplayer>().health -= se.damage;                                                           
           GameObject.Find("player").GetComponent&ltplayer>().hp.value = GameObject.Find("player").GetComponent&ltplayer>().health;
          
       }
       deadenemy.transform.position = new Vector3(20, 20, 0);
       enemies.Remove(se); //als de enemies de base raken worden ze gedestroyed
       Destroy(deadenemy);
       Destroy(GameObject.Find("enemy(Clone)").GetComponent&ltenemyhp>().iehp);
    }

</code>
            </pre>

        </div>
        <hr>
        
    <!--IO-->
    <h2 id="ioproject">Input Output Project</h2>
    <div class="projectview">
        <img src="projects/InputOutput/arduinogame.png" alt="">
        <video loop autoplay controls src="projects/InputOutput/iounfinished.mp4"></video>
        <video loop autoplay controls src="projects/InputOutput/unityproject.mp4"></video>
    </div>   
    <a href="https://github.com/Boil-1/InputOutput" target="_blank">Repository</a>
    <div class="projecttext">
        <h2>Introduction</h2>
        <p>
        Mijn idee voor dit project was om een flipperkast te maken met een arduino, en Unity om de scores mee bij te houden. 
        De flipperkast zou van karton gemaakt worden met sensoren eraan vast gemaakt.
        </p>
        <br>
        <h2>Functional</h2>
        <p>
        Eind verslag keuze onderdeel Input Output.
        link naar <a href="https://trello.com/b/gM2nCEdY/input-output">trello</a> <br>
        Mijn idee voor het keuze onderdeel Input Output was een flipperkast waarbij de score wordt bijgehouden in Unity. De input en output die hier origineel voor gekozen waren:
         een shock sensor, een electro magneet, een ultrasonic distance sensor,  LEDs, en knoppen. Daarna maakte ik een design van hoe ik de flipperkast wilde hebben,
          waar de sensors zouden komen en van welk materiaal de flipperkast gemaakt zou worden. Het materiaal zou van een dun soort hout gemaakt worden. 
          Het idee voor de flippers was om ze te 3d printen en metaal in te verwerken zodat de electro mageten ze kunnen aantrekken. 
          En een veer die er voor zorgt dat de flipper weer terug omhoog gaat zodra de electromagneet uit staat. 
          In dit design zie je waar alles zou moeten komen: <br>
        <a target="_blank" href="projects/InputOutput/flipperkast.png"><img id="pictureintext" title="the first design made in paint" src="projects/InputOutput/flipperkast.png"></a> <br>
        
        Toen alles was gerealiseerd kon ik gaan beginnen aan het maken van het project. Tijdens het maken van dit project kregen we lessen over hoe we de arduino en Unity met elkaar moeten
         verbinden en hoe je verschillende in en output leest en hoe je sensoren leest met de arduino. Ik gebruikte de arduino IDE om code te schrijven voor de arduino en de sensoren aan te 
         sturen, fusion 360 om het model te maken voor de kast en in	 unity gebruikte in de System.IO namespace om de port te lezen waar de arduino op stond. Toen begon met de shock sensor
          kwam ik erachter dat het in mijn geval niet handig zou zijn om te gebruiken. Vanwege de constructie van de flipperkast. 
        Daarna bedacht ik om een touch te gebruiken maar ik kwam er achter dat het alleen werkt met je hand of vinger en dat een metalen object er niet mee kan werken. 
        In dit plaatje kun je zien hoe het voorlopige design van de kast er uit zou zien:
        <a target="_blank" href="projects/InputOutput/Fusion360_0tWT2Z4eo1.png"><img id="pictureintext" title="later design made in fusion360" src="projects/InputOutput/Fusion360_0tWT2Z4eo1.png"></a> <br>
        Om er voor te zorgen dat de knop alleen 1 returnde als hij werd ingedrukt gebruikte ik een pull down resistor. Dat zorgt er voor dat er alleen stroom rond gaat als de knop word ingedrukt
         anders gaat het naar ground via een andere route. Zodra het variable van de knop word uitgelezen als 1 via digitalRead(pin nummer); word de functie digitalWrite gebruikt op de pin waar
          de electro magneet stroom van krijgt.  Als de knop word los gelaten zal er 0 gereturned worden en gaat de electro magneet uit. Op deze manier zou ik de flippers kunnen bewegen.
           Om de punten te lezen en als de bal in de gutter komt (langs de flippers valt) gebruikte ik eerst gewoon variables om de afstand te meten en de directe output te gebruiken maar mij
            werd later aangeraden om een library te gebruiken voor de afstand sensors. Er is een class genaamd NewPing met de variables welke pin de stroom van komt, 
        welke pin de ground is en wat de maximale afstand is die gemeten moet worden.
        Tijdens het maken zijn is er vaak getest, of de sensoren zouden werken zoals gewild. Op het eind toen het fysieke gedeelte (de kast) werd gemaakt waren er een paar problemen waardoor
         er geen houten plaat gebruikt kon worden en het gedeeltelijk ge3dprint moest worden.
         Toen de kast in elkaar werd gezet kwam ik er achter dat de electro magneten niet sterk genoeg waren om door 2 lagen plastic metaal aan te trekken. 
    </p>
    </div>
    <br>      
    <div class="snippet">
        <h2>Snippets</h2>
        <pre>
<code>
    public class ArduinoSerialCommunication : MonoBehaviour
    {
        SerialPort Serial;
        public TMP_Text ScoreText;
        public TMP_Text BallsText;
        public Sprite[] frames = new Sprite[4];
        public float framerate = 0.1f;
        float nextframe = 0.0f;
        public Image background;
        int length = 0;
        int highscore;

        void Start()
        {
            Serial = new SerialPort();
            Serial.PortName = "COM5";
            Serial.Parity = Parity.None;
            Serial.DataBits = 8;
            Serial.StopBits = StopBits.One;
            Serial.Open();
        }
    
        void Update()
        {
            if(Serial.BytesToRead > 0)
            {
                string[] info = Serial.ReadLine().Split(' ');
                string ballCount = Serial.ReadLine();
                 ScoreText.text = info[0];
                BallsText.text = info[1];
                if (int.Parse(info[1]) &lt 0)
                    SceneManager.LoadScene(1);
                Debug.Log(info[1]);
                PlayerPrefs.SetInt("score", Int32.Parse(info[0]));
                if (Int32.Parse(info[0]) > PlayerPrefs.GetInt("highscore", 0))
                    PlayerPrefs.SetInt("highscore", Int32.Parse(info[0]));
            }
            if (Time.time > nextframe)
            {
                if (length == 4)
                    length = 0;
                background.sprite = frames[length];
                length++;
                nextframe = Time.time + framerate;
            }
        }
    }

    <span class="annotation">//arduino code</span>

    void loop() {
        // put your main code here, to run repeatedly:
        int k1 = digitalRead(2);
        int k2 = digitalRead(3);
        
        //get score
        duration = sonar.ping();                        
        distance = (duration/2)*0.0343;
        //Serial.println(score);
        if(distance &lt 3.00){
          getScore = true;
        }
        else if(distance > 3.00){
          getScore = false;
        }
        if(getScore){
          score += 10;
        }
    }

    <span class="annotation">//score count</span>

    //ball count
  durationBallS = sonarBall.ping();
  distanceBallS = (durationBallS/2)*0.0343;
  int previousBallAmount = ballsAmount;
  if(distanceBallS > 3.00){
    getBallAmount = true; 
  }
  if(getBallAmount){
    ballsAmount--;
    getBallAmount = false;
    delay(2000);
  }
  if(ballsAmount == 0){
    gameOver = true;
  }
  Serial.println(String(score)+" "+String(ballsAmount));

   if(k2 > 0){
    Serial.println(Lbumper);
    digitalWrite(6, HIGH);
  }
  else if(k2 &lt= 0)
    digitalWrite(6, LOW);
  if(k1 > 0){
    Serial.println(Lbumper);
    digitalWrite(7, HIGH);
  }
  else if(k1 &lt= 0)
    digitalWrite(7, LOW);
    
      
</code>
        </pre>

    </div>

    <hr>

    <!--after the fall vertical slice-->
    <h2 id="atf">After The Fall Vectical Slice</h2>
    
    <div class="projectview">
        <img src="projects/AfterTheFallVerticleSlice/ATFverticleslice.png" alt="">
        <img src="projects/AfterTheFallVerticleSlice/c6075f6c7ea16b2cb1b4d8dee48cfb18.gif" alt="">
    </div>   
    <a href="https://github.com/Boil-1/InputOutput" target="_blank">Repository</a>
    <div class="projecttext">
        <h2>Grijpbare Object Interactie</h2>
        <h2>Pak Objecten Op</h2>
        <br>
        <h2>Functioneel</h2>
        <p>Wanneer de speler dichtbij een object is zal er een indicator komen rondom het object, het geeft een kleine beschrijving van het voorwerp. <br>
            Wanneer de middel vinger knop wordt ingedrukt beweegt het object snel naar je hand.
        </p>
        <p>Je kan dit voorwerp op pakken:</p>
        <br>
        <img width="500" src="https://user-images.githubusercontent.com/91535051/208069282-342c770a-a9d7-4c7f-9a57-a3af8ce6e9ec.png" alt="pickup">    
        <br>
        <p>Je bent dichtbij genoeg om het voorwerp op te pakken: </p>
        <img width="500" src="https://user-images.githubusercontent.com/91535051/208069288-1978992c-3ef3-4769-a61e-3d709d1ece67.png" alt="canpickup">
        <br>
        <p>Je kan voorwerpen op pakken in de vertical slice: </p>
        <img width="500" src="https://user-images.githubusercontent.com/91535051/213674957-89030210-db2a-4fe9-b544-5eff057ee7e2.png" alt="vertical slice pickup">
        <br>
        <br>
        <h2>Technisch</h2>
        <h3>Find Closest Object Near Raycast</h3>
        <p>Een raycast word gecast vanaf beide handen en loopt door alle objecten met een grab component in de bol raycast aan het einde van de raycast. <br>
            Het schakelt de physics van het dichtst bijzijnde object uit.
        </p>
             <br>
             <h3>Find Closest Object Within Sphere Trace</h3>
             <p>Het dichtst bijzijnde object is gevonden en word opgeslagen in het varable ClosestFoundObject
             </p>
            <br>
            <h3>Move Object</h3>
            <p>Wanneer het dichtst bijzijnde object is gevonden word de afstand tussen zijn positie en de positie van de hand berekend en genormaliseerd. <br>
                Nadat het object naar de hand wordt toe aangetrokken. <br>
                Als het object dichtbij genoeg is wordt het vast gepakt.</p> 
                  <br>
                  <h3>Grab Object</h3>
                  <p>
                    De positie van het object is gesnapt naar de positie van de hand en de variables <br>
                    HeldComponent Left/Right, PullingObject Left/Right en bIsPulling Left/Right worden naar null gezet.</p>
                  <br>
                  <h3>Grabbable Object Trace</h3>
                  <p>Op de transform van het dichtst bijzijnde object word een outline gespawned die word vernietigd wanneer de raycast naar een ander object wijst of naar niets.
                  </p>
                  <br>
                  <h3>Flowchart</h3>
                  <p>Een versimpelde flowchart van hoe het systeem werkt:
                </p>
                  <br>
                  <a target="_blank" href="https://user-images.githubusercontent.com/91535051/213692964-efeaf606-94c1-40e3-a2df-027339eca69d.png"><img width="500" class="enlargeimage" src="https://user-images.githubusercontent.com/91535051/213692964-efeaf606-94c1-40e3-a2df-027339eca69d.png" alt="flowchart"></a>
    </div>

    <!--END-->      
    </div>
    <a class="totop" href="#top">to top↑</a>
    </body>
</html>



